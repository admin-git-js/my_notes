![[flex_box.png]]
Flexbox, або Flexible Box Layout, — це потужна система розмітки в CSS, розроблена для створення одновимірних макетів. Це означає, що Flexbox найкраще підходить для розташування елементів в одному рядку або в одному стовпці. Він значно спрощує створення гнучких та адаптивних інтерфейсів, особливо коли потрібно вирівнювати та розподіляти простір між елементами всередині контейнера.

Ось ключові концепції та переваги Flexbox:

**Основні Концепції:**

1. **Flex-контейнер (Flex Container):** Це батьківський елемент, який містить елементи, що потрібно розмістити за допомогою Flexbox. Щоб зробити елемент flex-контейнером, йому потрібно задати властивість `display` зі значенням `flex` або `inline-flex`.
    
    CSS
    
    ```css
    .container {
      display: flex; /* Блоковий flex-контейнер */
      /* display: inline-flex; Інлайновий flex-контейнер */
    }
    ```
    
2. **Flex-елементи (Flex Items):** Це безпосередні дочірні елементи flex-контейнера. Браузер автоматично перетворює ці елементи на flex-елементи.
    
    HTML
    
    ```html
    <div class="container">
      <div>Елемент 1</div>
      <div>Елемент 2</div>
      <div>Елемент 3</div>
    </div>
    ```
    
3. **Основна вісь (Main Axis) та поперечна вісь (Cross Axis):**
    
    - **Основна вісь:** Це вісь, вздовж якої розташовуються flex-елементи. За замовчуванням вона є горизонтальною (зліва направо) в мовах з лівостороннім написанням. Напрямок основної осі можна змінити за допомогою властивості `flex-direction`.
    - **Поперечна вісь:** Це вісь, перпендикулярна до основної осі. Якщо основна вісь горизонтальна, поперечна вісь є вертикальною (зверху вниз), і навпаки.

**Основні Властивості Flex-контейнера:**

- `flex-direction`: Визначає напрямок основної осі. Можливі значення: `row` (за замовчуванням, горизонтально), `row-reverse` (горизонтально у зворотному порядку), `column` (вертикально), `column-reverse` (вертикально у зворотному порядку).
    
- `flex-wrap`: Визначає, чи повинні flex-елементи переноситися на новий рядок або стовпець, якщо вони не вміщаються в контейнері. Можливі значення: `nowrap` (за замовчуванням, не переносити), `wrap` (переносити на нові рядки/стовпці), `wrap-reverse` (переносити на нові рядки/стовпці у зворотному порядку).
    
- `flex-flow`: Скорочена властивість для одночасного встановлення `flex-direction` та `flex-wrap`. Наприклад: `flex-flow: row wrap;`.
    
- `justify-content`: Визначає вирівнювання flex-елементів вздовж основної осі. Можливі значення: `flex-start` (за замовчуванням, вирівнювання на початку), `flex-end` (вирівнювання в кінці), `center` (вирівнювання по центру), `space-between` (рівномірний розподіл простору між елементами), `space-around` (рівномірний розподіл простору навколо елементів), `space-evenly` (рівномірний розподіл простору між елементами та навколо них).
    
- `align-items`: Визначає вирівнювання flex-елементів вздовж поперечної осі. Можливі значення: `stretch` (за замовчуванням, розтягує елементи на всю висоту/ширину контейнера), `flex-start` (вирівнювання на початку поперечної осі), `flex-end` (вирівнювання в кінці поперечної осі), `center` (вирівнювання по центру поперечної осі), `baseline` (вирівнювання за базовою лінією тексту).
    
- `align-content`: Визначає вирівнювання ліній flex-елементів вздовж поперечної осі, коли є кілька рядків/стовпців (тобто коли використовується `flex-wrap: wrap` або `flex-wrap: wrap-reverse`). Можливі значення аналогічні `justify-content`, але застосовуються до ліній.
    

**Основні Властивості Flex-елементів:**

- `order`: Визначає порядок відображення flex-елементів всередині контейнера. За замовчуванням всі елементи мають `order: 0`. Елементи з меншим значенням `order` відображаються раніше.
    
- `flex-grow`: Визначає коефіцієнт зростання flex-елемента, якщо є вільний простір у контейнері вздовж основної осі.
    
- `flex-shrink`: Визначає коефіцієнт стискання flex-елемента, якщо недостатньо місця в контейнері вздовж основної осі.
    
- `flex-basis`: Визначає початковий розмір flex-елемента вздовж основної осі перед розподілом вільного простору. Може приймати значення довжини (наприклад, `px`, `%`) або `auto` (розмір залежить від вмісту). Властивість `flex` є скороченням для `flex-grow`, `flex-shrink` та `flex-basis` (за замовчуванням `0 1 auto`).
    
- `align-self`: Дозволяє індивідуально переопределити вирівнювання окремого flex-елемента вздовж поперечної осі, перекриваючи значення, задане для `align-items` у flex-контейнері. Можливі значення аналогічні `align-items`.
    

**Переваги використання Flexbox:**

- **Просте вирівнювання:** Flexbox значно полегшує вирівнювання елементів як по горизонталі, так і по вертикалі.
- **Адаптивність:** Дозволяє створювати гнучкі макети, які добре виглядають на різних розмірах екранів.
- **Порядок відображення:** Можна змінювати порядок відображення елементів без зміни їх порядку в HTML-коді за допомогою властивості `order`.
- **Розподіл простору:** Flexbox надає потужні інструменти для розподілу вільного простору між елементами.

Flexbox є незамінним інструментом для сучасного веб-розробника і значно спрощує багато завдань, пов'язаних з розміткою сторінок. Він особливо корисний для створення навігаційних меню, компонентів інтерфейсу, галерей зображень та інших одновимірних макетів.

### safe unsafe 
У Flexbox, ключові слова `safe` та `unsafe` використовуються разом із властивостями вирівнювання, такими як `justify-content` та `align-items`. Вони впливають на поведінку вирівнювання в ситуаціях, коли flex-елементи переповнюють свій контейнер.

Основна ідея цих ключових слів полягає в запобіганні **втраті даних** (коли частина вмісту стає недоступною для користувача, наприклад, її неможливо прокрутити) у випадках переповнення.

Ось як вони працюють:

- **`unsafe`**: Це ключове слово вказує браузеру застосовувати вказане вирівнювання (наприклад, `center`, `flex-end`) незалежно від того, чи призведе це до переповнення контейнера та потенційної втрати даних. Браузер буде намагатися вирівняти елементи згідно із заданою властивістю, навіть якщо це означає, що частина елементів вийде за межі контейнера і стане недоступною для прокрутки.
    
- **`safe`**: Це ключове слово є більш "безпечним" варіантом. Воно намагається застосувати вказане вирівнювання. Однак, якщо застосування цього вирівнювання призведе до переповнення контейнера та потенційної втрати даних на "початковому" краю осі, то замість цього буде застосовано вирівнювання `start` (вирівнювання до початку відповідної осі). Це гарантує, що початкова частина елементів завжди буде доступна для користувача.
    

**Приклад використання:**

Ви можете використовувати `safe` або `unsafe` разом зі значеннями вирівнювання, наприклад:

```css
.container {
  display: flex;
  /* Вирівнювання по центру, але безпечне при переповненні */
  justify-content: safe center;
  /* Вирівнювання елементів по центру поперечної осі, але безпечне при переповненні */
  align-items: safe center;
}
```

або

```css
.container {
  display: flex;
  /* Вирівнювання по центру, навіть якщо це призведе до втрати даних */
  justify-content: unsafe center;
}
```

**Коли це може бути корисно?**

Уявіть собі flex-контейнер з обмеженою шириною, який містить кілька flex-елементів. Якщо ви використовуєте `justify-content: center;`, і сукупна ширина елементів перевищує ширину контейнера, елементи будуть відцентровані, але частини елементів по краях можуть виявитися недоступними для прокрутки (якщо переповнення відбувається в напрямку, який не прокручується).

Використання `justify-content: safe center;` в цьому випадку призведе до того, що при переповненні вирівнювання зміниться на `start`. Це гарантує, що початковий край елементів буде вирівняно до початку контейнера, дозволяючи користувачеві прокручувати, щоб побачити весь вміст.

**Підтримка браузерами:**

Варто зазначити, що підтримка ключових слів `safe` та `unsafe` може відрізнятися в різних браузерах та їх версіях. Завжди корисно перевіряти сумісність, наприклад, на сайті Can I Use.

Загалом, використання `safe` є рекомендованим підходом, оскільки воно допомагає уникнути неочікуваної втрати даних та покращує доступність вашого інтерфейсу при роботі з переповненням у Flexbox.

### gap 
Звісно! Властивість `gap` в CSS є дуже корисною для створення проміжків (відступів) між елементами в **CSS Grid** та **Flexbox** макетах. Вона спрощує додавання відступів, уникнення проблем з крайніми елементами, які можуть виникати при використанні `margin`.

Властивість `gap` є скороченням для двох інших властивостей:

* `row-gap`: Встановлює проміжок між **рядками**.
* `column-gap`: Встановлює проміжок між **стовпцями**.

Ви можете використовувати їх окремо або разом за допомогою скорочення `gap`.

#### Використання `gap` у CSS Grid:

У CSS Grid `gap` (або `grid-gap`, що є застарілим синонімом) застосовується до **грід-контейнера** і створює проміжки між елементами сітки.

* **Задання однакового проміжку між рядками та стовпцями:**

    ```css
    .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr); /* Наприклад, 3 однакові стовпці */
      gap: 20px; /* Відступ 20px між усіма рядками та стовпцями */
    }
    ```

* **Задання різних проміжків для рядків та стовпців:**

    ```css
    .grid-container {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      row-gap: 15px; /* Відступ 15px між рядками */
      column-gap: 30px; /* Відступ 30px між стовпцями */
      /* Або за допомогою скорочення: */
      /* gap: 15px 30px; */ /* Перше значення для row-gap, друге для column-gap */
    }
    ```

#### Використання `gap` у Flexbox:

Властивість `gap` також підтримується у Flexbox контейнерах (застосовується до елемента з `display: flex` або `display: inline-flex`). Вона створює проміжки між флекс-елементами.

* **Задання однакового проміжку між флекс-елементами:**

    ```css
    .flex-container {
      display: flex;
      gap: 10px; /* Відступ 10px між флекс-елементами */
      /* Якщо flex-direction: row (за замовчуванням), це буде column-gap */
      /* Якщо flex-direction: column, це буде row-gap */
    }
    ```

* **Задання різних проміжків вздовж головної та поперечної осей:**

    ```css
    .flex-container {
      display: flex;
      flex-direction: row; /* Елементи в ряд */
      row-gap: 10px; /* Відступ між рядками (якщо елементи переносяться) */
      column-gap: 20px; /* Відступ між стовпцями */
      /* Або за допомогою скорочення: */
      /* gap: 10px 20px; */
      flex-wrap: wrap; /* Важливо для демонстрації row-gap */
    }
    ```
    Якщо `flex-direction: column;`, `row-gap` буде створювати проміжки між елементами у стовпці (вздовж головної осі), а `column-gap` - між стовпцями (вздовж поперечної осі, якщо `flex-wrap: wrap;`).

**Переваги використання `gap`:**

* **Простота:** Легко додавати рівномірні відступи між елементами без складних розрахунків або використання негативних `margin`.
* **Чистота коду:** Уникає потреби у правилах для першого/останнього або кожного n-го елемента для уникнення зайвих відступів по краях.
* **Адаптивність:** Відступи, задані за допомогою `gap`, автоматично адаптуються при зміні розміру контейнера або перенесенні елементів.

Властивість `gap` значно спрощує створення проміжків у сучасних макетах на основі Flexbox та Grid, роблячи код чистішим та легшим для розуміння.